# client
1. client，开始至少一个baseVer
2. client可能，当前无编辑状态，收到op直接apply<br/>
    当前有编辑状态，等待服务端确认
    当前有编辑状态，且收到服务端op，变换后apply（提交未返回前不变换与apply，降低复杂度与保证优先级与服务端一致），此时若再有本地编辑，变换应用后再提交（旧提交未返回前不提交）新的本地编辑（本地未提交的一定比服务端过来的靠后）<br/>
    特定情况：收到服务端返回，但提交的未应用（reject），需要变换后再次提交（这种情况要检查服务端返回的op是否有本地提交的，查第一个就行）<br/>
    当前无论有无编辑状态，收到不与baseVar连续的服务端op，都舍弃重新请求<br/>
    *本地记录与服务端相同序号的op序列，(基于应用op后结果一致)<br/>
    本地提交的op，没返回前不提交新的op（超时重新提交），方便整合本地op序列（事务合并与保持与服务端顺序一致）<br/>

# 服务端
服务端有一个baseVer列表，随时收到基于某个版本的op，进行变换后apply，并返回op的应用序号<br/>
如对应baseVar不在内存中（长时间离线编辑），返回前端baseVar开始的op序列，前端变换后再提交<br/>
有种情况，客户端重复提交op（网络原因等），需要查找baseVar之后一定长度的op序列（内存支持的长度，否则是前端合并后再重新提交）<br/>
主服务端与从服务端<br/>
1. 从服务端进行批量变换后批次提交到主服务端，待主服务端返回结果整合后返回client<br/>
2. 从服务端从主服务端承接某个节点的op服务，再返回给主服务端（这个比较好，可基于go/rust的多线程实现）<br/>

# 选区
本地cmd带备份选区，需要同步变换更新<br/>
本地selection、远程selection进入变换队列<br/>

# crdt
https://crdt.tech/

# undo对象操作如何保证各端数据一致
1. undo insert, modify 直接变换cmd/op就行<br/>
2. undo delete, (如delete还未提交，如离线，则本地消掉就行) <br/>
    2.1 delete时暂存一份对象数据副本，本地数据仅从对象树中移除，数据不删，repo保留<br/>
    2.1.1 修改：不暂存数据，而是在undo时提交一份最近版本的数据。
    2.2 待delete返回后，将对象数据副本及本地数据更新到delete对应的版本，并将副本记录到本地delete cmd<br/>
    2.3 undo delete时，对象数据带版本号，此时<br/>
        2.3.1 本地数据未删除，数据是本地最新，含有delete版本前后的数据<br/>
        2.3.2 其它用户数据，替换本地对象数据并取得delete版本后的cmd，则将此对象相关的修改重新应用一遍；<br/>
3. undo 数量限制为100？以防止需要从服务端请求太多cmd<br/>
4. 提交给服务端的op未返回前，不会继续提交新的op，超时或者返回版本问题，需要重新提交相同的op集合，不得多提交（保证提交的op，回来版本号是连续一致的，降低算法复杂度。离线编辑，需要把这个信息存储下）<br/>
    4.1 不多提交可以保证服务端收到的cmd要么是都已应用或者都未应用的，可以简化算法。同时保证返回给客户端的cmd是连续应用的，同样可以简化算法。<br/>
    4.2 未返回前不提交，同样也简化了算法，以达到可控的状态<br/>
5. 提交未返回前收到服务端op, 暂存不处理，等待返回后再处理<br/>
    5.1 这么做的原因是保证提交的op与服务端过来的op做变换时，order是完全一致的<br/>
    fix : 不需要的，因为过来的op必须是连续的，不连续的丢弃。这条可以保证order是完全一致的<br/>
6. 多个用户同时delete同一个对象，收到ud cmd的端都执行替换后更新操作，最终结果一致<br/>

# todo
1. symbol是要求整个文档id唯一，如果出现在不同page插入会怎样？由于page数据是异步加载的，也没办法检查是否唯一。<br/>
    解决办法：所有symbol放入一个page，然后page中区分symbolref与symbolslot，symbolslot本身不带任何数据，可以直接修改symbol数据。<br/>
    需要注意：这样处理后一个cmd会处理包含两个page的数据。<br/>
    如何保证文档中的所有page只有一个symbol：在symbol中存上所属的pageid及order。是否需要symbolslot？还是要。<br/>

client 可以引用data数据

需要获取当前baseVer更早的版本的情况
1. undo delete reponode，时，cmd的数据版本比baseVer小
todo 应该怎么处理更新回来的cmd? 直接插入到当前ops的前面


当前版本太旧提交时被拒绝
拉取到服务端支持的版本本地更新后再提交


todo 本地order应该设置为多少？？
数据导入时0，最小，后续可改
本地编辑时MAX_SAFE_INTEGER, 最大，远程过来的op不会动到本地的。此数据也不会写入到文档，除非本地保存版本。
如果本地保存版本直接上传，需要修改此order!


todo index的order怎么更新为op.order,
todo 本地undo后的op也要实时变换，以在redo时可直接用。


undo delete
1. 当被undo的op已经有版本号，则undoop记录对应版本号的数据
2. 当被undo的op正在上传，则待上传返回后，在undo-do-redo时重新更新undo记录的数据到返回的op的版本
3. 当被undo的op还没上传，直接本地消掉不再上传